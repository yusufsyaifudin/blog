"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/blog/posts/2023-02-24-rails-otel-intro/",title:"Better Observability on Ruby on Rails Logs with OpenTelemetry Trace and Span ID",section:"Blog",content:`Ruby on Rails (RoR) is a common framework used by Ruby developers when building web application. It ships with common libraries from logger to active record (for easily querying from database). But, like many current framework in others programming language, we need to write some extra code to make our application easier to observe and debug. For example, on small traffic application we may satisfied by printing some logging such as:
myapp | Started GET &#34;/list-vouchers&#34; for 192.168.32.1 at 2023-03-09 03:26:00 +0000 myapp | Cannot render console from 192.168.32.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1 myapp | ActiveRecord::SchemaMigration Pluck (1.8ms) SELECT &#34;schema_migrations&#34;.&#34;version&#34; FROM &#34;schema_migrations&#34; ORDER BY &#34;schema_migrations&#34;.&#34;version&#34; ASC myapp | Processing by UserPromotionController#list_vouchers as HTML myapp | request accepted by controller myapp | accepting token from headers myapp | validating JWT myapp | reaching business logic myapp | doing query get user by id c8c6991c-687e-44cc-8755-4743ef66d265 myapp | User Load (2.2ms) SELECT &#34;users&#34;.* FROM &#34;users&#34; WHERE &#34;users&#34;.&#34;id&#34; = $1 LIMIT $2 [[&#34;id&#34;, &#34;c8c6991c-687e-44cc-8755-4743ef66d265&#34;], [&#34;LIMIT&#34;, 1]] myapp | â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39; myapp | calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265 myapp | PromotionService.list_vouchers call started myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 314ms (Views: 12.1ms | ActiveRecord: 9.0ms | Allocations: 8720) This log is taken from the code from the Rails app that I write in part 1.
But, as our web application traffic become heavy, it will become hard to pinpoint on specific user&rsquo;s request journey.
Let me tell you why this will become the problem and how we can improve this.
Supposed you have 16 line of log above, repeated multiple times because of high traffic, then:
How you can ensure that the next line of the log is sequentially correspond with the previous line? How you will group the log based on one request journey? How can we sorting by time? It is text based, then if you successfully sort that, it probably you&rsquo;re sorting the whole line (not specific by time). And another question on how we get the better sense of the log. The Problem # The default Rails log output is hard to debug. I think it is not only me who feel that. Even ChatGPT tell me this when I asked why rails app log hard to debug:
![Figure 1. ChatGPT&rsquo;s opinion of Rails log outputs]( {{ absLangURL &ldquo;/post-assets/2023-02-24/chatgpt-why-rails-app-log-hard-to-debug.png&rdquo; }} )
Figure 1. ChatGPT's opinion of Rails log outputs Below is the ChatGPT generated text
Rails app logs can be hard to debug for several reasons:
Complexity: Rails applications can be complex with many layers of code that interact with each other. This can make it difficult to pinpoint the root cause of an issue. Volume: Rails logs can generate a large volume of information, making it difficult to find the relevant information needed to debug an issue. Lack of structure: Rails logs can lack structure, making it difficult to identify the relevant information needed to debug an issue. Lack of context: Rails logs may not provide enough context to understand the flow of the application, making it difficult to understand how the different parts of the application are interacting. Lack of tooling: Traditional text editors or command line tools may not be well suited for analyzing logs, and dedicated log analysis tools can be expensive or require specialized knowledge. To make Rails app logs easier to debug, developers can:
Use logging frameworks like Lograge or Semantic Logger that provide more structure and context to logs. Configure logging to only include relevant information and to filter out noise. Use log analysis tools like Elasticsearch or Splunk to search, filter, and analyze logs. Implement error tracking tools like Sentry or Airbrake to automatically capture and group errors and provide context for debugging. Use logging libraries like Pry or Byebug to interactively debug code during runtime. End of ChatGPT generated text
In this part, I will not talk much about it. I will explain why it become problem in [the Part 2]( {{ absLangURL &ldquo;/posts/2023-02-24-rails-otel-part2&rdquo; }} ) with an example and then try to solve it. But, before jump to solution, I must prepare the clean Rails Application in [the Part 1]( {{ absLangURL &ldquo;/posts/2023-02-24-rails-otel-part1/&rdquo; }} ) as I haven&rsquo;t touch the Ruby on Rails for years.
Each section on each part will always include with the specific commit id. It will help you (and me in the future) to follow the tutorial, so we can reproduce by running git checkout and docker compose up --build --force-recreate, and we will get the similar result as shown in this tutorial.
Using OpenTelemetry to Trace User Journey # OpenTelemetry came as a set of standard to make developer (and also ops) easier to see the application traces, metrics and logs by instrumenting the code. But, when this tutorial is written, the OpenTelemetry SDK for Ruby version 1.2.0 (with commit id ad7c3b9c4fcdf2f74705a9ac08310b7067e97162) not supports OpenTelemetry Metric and Logging.
![Figure 2. OpenTelemetry Ruby SDK Page]( {{ absLangURL &ldquo;/blog/post-assets/2023-02-24/opentelemetry-ruby-sdk-page.png&rdquo; }} )
Figure 2. OpenTelemetry Ruby SDK Page So, as the workaround to make standard logging that can be linked to the trace, we need to implement the OTEP0114 which add these property in our existing log output:
&ldquo;trace_id&rdquo; hex-encoded. &ldquo;span_id&rdquo; hex-encoded. &ldquo;trace_flags&rdquo; formatted according to W3C traceflags format. References:
https://github.com/open-telemetry/opentelemetry-specification/blob/v1.18.0/specification/logs/README.md?plain=1#L474-L526 https://github.com/open-telemetry/oteps/pull/114 Using JSON as the Log Format Output # In the OpenTelemetry page discussing Trace Context in Legacy Formats, there no advice to use JSON format over the Syslog RFC5424 or other format. But in my opinion, using JSON as the log format output will make debugging more easier because it can be stored into NoSQL database and then query it. In result, by able to query the logs, we can group the logs based on trace_id which means that all logs with the same trace_id are produced by the one request journey from the client.
![Figure 3. Trace Context in Legacy Formats]( {{ absLangURL &ldquo;/blog/post-assets/2023-02-24/opentelemetry-trace-context-in-legacy-format.png&rdquo; }} )
Figure 3. Trace Context in Legacy Formats Part 1: Preparing the Ruby on Rails Application # If you are new to the Ruby on Rails, you can follow this [part 1]( {{ absLangURL &ldquo;/posts/2023-02-24-rails-otel-part1/&rdquo; }} ). Otherwise, go to [Part 2.]( {{ absLangURL &ldquo;/posts/2023-02-24-rails-otel-part2/&rdquo; }} )
Part 2: Improving Log Output # Go to this link for the [Part 2.]( {{ absLangURL &ldquo;/posts/2023-02-24-rails-otel-part2/&rdquo; }} )
`}),e.add({id:1,href:"/blog/posts/2023-02-24-rails-otel-part1/",title:"Better Observability on Ruby on Rails Logs with OpenTelemetry Trace and Span ID (Part 1 - Preparing Rails Application)",section:"Blog",content:`In this part, I will mainly focusing on preparing Rails application. If you already know about the Rails and want to only focusing on how to make the logs better, you can skip this part and jump to Part 2.
Prepare Rails Application # To make this tutorial is easier to follow both for experienced RoR developers and newcomers, I will create easy to follow step by step tutorial from installing Rails to adding OpenTelemetry library to customize the log output in Rails application. I hope it also gives you (the reader) idea on how adding OpenTelemetry on your existing code.
WARNING!!!
All code in this tutorial is not production ready! For example, I don&rsquo;t validate JWT token but only decode it.
Installing Rails # I will not tell you to install Ruby and Rails in your host machine. I suggest you to install Docker by following this link:
Install on Mac https://docs.docker.com/desktop/install/mac-install/ Install on Windows https://docs.docker.com/desktop/install/windows-install/ Install on Linux https://docs.docker.com/desktop/install/linux-install/ Then you can pull the Docker Ruby image:
docker pull ruby:3-bullseye This command will pull the Docker image Ruby with version 3 using Debian codename &ldquo;bullseye&rdquo;.
Now, save this file as create-rails.sh in your project directory. For example, you create the project directory in ~/Project, then save it as ~/Project/create-rails.sh.
This is the script to install Rails version 7.0.4.2 and create new Rails project with name rails-otel.
#!/bin/sh gem install rails -v 7.0.4.2 rails new rails-otel Then we can create a Rails project by running this command in your project directory (from the same location where you save the create-rails.sh file):
docker run -v $(pwd)/rails-otel:/rails-otel -v $(pwd)/create-rails.sh:/create-rails.sh:ro ruby:3-bullseye /bin/bash create-rails.sh Above command will tell Docker to run Docker image ruby:3-bullseye by mounting two volumes:
$(pwd)/rails-otel:/rails-otel means that we will make any files written by Docker container to persist in our host machine. $(pwd)/create-rails.sh:/create-rails.sh:ro tells Docker to include the create-rails.sh file from host machine to the container with read only mode. This is file that we need to run inside the Docker container. Then argument /bin/bash create-rails.sh tells Docker to run that command inside the Docker container ruby:3-bullseye.
Now, in the project directory ~/Project you will find new folder containing the Rails code in ~/Project/rails-otel.
Yay! We have created a clean Rails project without installing Ruby and gem Rails in our host machine!
You can see it in this commit: 8540614
Running Rails using Docker # Now, we already have clean Ruby on Rails project, and it will means nothing if we don&rsquo;t run it. Again, since we don&rsquo;t install any Ruby nor gem install rails in our host machine, we need to run it using Docker too.
First, create a file with name entrypoint.sh in the Rails project:
#!/bin/bash set -e # Remove a potentially pre-existing server.pid for Rails. rm -f /myapp/tmp/pids/server.pid # Then exec the container&#39;s main process (what&#39;s set as CMD in the Dockerfile). exec &#34;$@&#34; As you can read in the comment, it needed to remove any potential pre-existing server.pid for Rails to run.
Then, create another file named development.Docker in the root Rails project directory:
FROM ruby:3-bullseye RUN apt-get update -qq # Set workdir to &#34;myapp&#34; WORKDIR /myapp # Copy Gemfile and download all Gem required to run. # This minimize the build time because \`bundle\` doesn&#39;t need to scan all source code. COPY Gemfile /myapp/Gemfile COPY Gemfile.lock /myapp/Gemfile.lock RUN bundle install # Add a script to be executed every time the container starts. COPY entrypoint.sh /usr/bin/ RUN chmod +x /usr/bin/entrypoint.sh EXPOSE 3000 ENTRYPOINT [&#34;entrypoint.sh&#34;] What we do here is copying Gemfile and Gemfile.lock into Docker container with base image ruby:3-bullseye. After that, we run bundle install to download all gem dependencies required by our Rails application to run.
Then, we copy entrypoint.sh make it executable by apply chmod +x permission into it and make it as Docker ENTRYPOINT. We also add EXPOSE 3000 to tell Docker to expose port number 3000.
You may ask where we put the rest of our Ruby code? Why it didn&rsquo;t COPYed to container?
The answer of this question is: No, we didn&rsquo;t need to copy our file into Docker container. Because, in this part what we only need is to run Rails application inside Docker container, and we can modify the code via any IDE installed in our host. In this part, our goal is not to make final Docker image to be deployed somewhere, but we use Docker as our development environment.
Finally, to make easier to run, we can use Docker Compose by creating new file named docker-compose.yml:
version: &#39;3.8&#39; services: myapp: container_name: myapp build: dockerfile: development.Dockerfile restart: always command: bundle exec rails s -p 3000 -b &#39;0.0.0.0&#39; ports: - &#34;3000:3000&#34; volumes: - ./:/myapp In above code, we name our Rails application as myapp with Dockerfile referenced to the file development.Dockerfile we have created above. Then we mount the volume ./:/myapp which means that myapp service will have access of all files in the host current directory and mapped it into /myapp directory inside the Docker container.
Then we need to run command bundle exec rails s -p 3000 -b '0.0.0.0' for Rails application to run in port 3000.
After creating those 3 files (Dockerfile, entrypoint.sh and docker-compose.yml) we can run our Rails app by executing this command:
docker compose up --build --force-recreate We will see our terminal similar like this:
Figure 1. Running Rails using Docker Compose Now, access your browser at http://localhost:3000 it should look like this:
Figure 2. RoR homepage on fresh install You can see all changes of this section on this commit: 1502a09
Add route mimicking nested function calls operation # As this article is focusing on how we can get better observability of the logs emitted by Rails application, we need add one route in our router that do nested function calls. This mimicking the real-world application, where one API may do several function calls (or sometimes 3rd party call) before it return response to the user.
For this tutorial, I will create a router where user can apply a Voucher code. I will create the route:
GET /list-vouchers?token=jwt-token Which will return list of promotion voucher code that can only be accessed by the user (so we need to check whether the user is exists in database or not).
The response will looks like this:
[ { &#34;user&#34;: { &#34;id&#34;: &#34;f2c2d7ba-0d2b-4f2d-8a6c-6b3a69c8d87e&#34;, &#34;username&#34;: &#34;a&#34;, &#34;name&#34;: &#34;a&#34;, &#34;created_at&#34;: &#34;2023-02-28T11:08:36.000Z&#34;, &#34;updated_at&#34;: &#34;2023-02-28T11:08:38.000Z&#34; }, &#34;vouchers&#34;: [ [ { &#34;voucher_code&#34;: &#34;REGISTER_ANNIVERSARY&#34;, &#34;description&#34;: &#34;will get 5% discount if user is a loyal users (already joined minimum 1 year)&#34;, &#34;terms_and_conditions&#34;: [ { &#34;discount&#34;: 5, &#34;min_registered_year&#34;: 1, &#34;registered_date_is_same&#34;: true, &#34;registered_month_is_same&#34;: true, &#34;name_prefix&#34;: &#34;&#34; } ] } ] ] } ] In this process, we need to:
Get the Authorization token, either from Header or query params. Parse the JWT, and get the user id from token. Check if the user id is exists on the database. Call service Promotions (for now we create a Class that return static output) if user is exist in database, otherwise return error. This article only focus to show you how to create better logging, so there is may security hole in the code.
Let&rsquo;s code that!
Preparing Postgres Database and Gem Library To Connect # Before we create any Ruby code, we need a database to be use by our code. We use Postgres 15 using Docker.
First, stop our previous docker run command (docker compose up --build --force-recreate) in the terminal by using CTRL + C. Then command docker compose down to make sure all container is stopped.
Then, in our docker-compose.yml file, change to this:
version: &#39;3.8&#39; services: myapp: container_name: myapp build: dockerfile: development.Dockerfile restart: always command: bundle exec rails s -p 3000 -b &#39;0.0.0.0&#39; ports: - &#34;3000:3000&#34; volumes: - ./:/myapp depends_on: - postgres environment: DATABASE_USERNAME: root DATABASE_PASSWORD: password postgres: image: postgres:15 container_name: postgres restart: always ports: - &#34;5433:5432&#34; environment: - POSTGRES_USER=root - POSTGRES_PASSWORD=password - POSTGRES_DB=postgres - POSTGRES_INITDB_ARGS=&#34;--data-checksums&#34; volumes: - ./docker-data/postgres:/var/lib/postgresql/data - ./docker-postgres-init.sql:/docker-entrypoint-initdb.d/docker-postgres-init.sql:ro This will tell Docker to add new container postgres:15 with username root and password password. And passing this credentials to myapp container.
Then, as we specified in the volumes section, we need to create a file with name docker-postgres-init.sql in our root project directory:
CREATE DATABASE rails_otel_dev; GRANT ALL PRIVILEGES ON DATABASE rails_otel_dev TO root; This will tell the Postgres to create 3 databases (rails_otel_dev, rails_otel_test, and rails_otel_prod) when first run. All data will be persisted in ./docker-data/postgres as we mount our Docker volume into it.
Don&rsquo;t forget to add docker-data in the .gitignore to ensure that all data created by Postgres is not committed to our Git repo.
37 # Ignore IDE index file 38 /.idea + 39 docker-data 40 Then, to make our Rails application can connect to Postgres, we need to add pg Gem library, by adding to the Gemfile:
50 + 51 # Pg is the Ruby interface to the PostgreSQL RDBMS. It works with PostgreSQL 9.3 and later. + 52 gem &#39;pg&#39;, &#39;~&gt; 1.4&#39;, &#39;&gt;= 1.4.6&#39; 53 Lastly, in change the config/database.yml file with this configuration:
default: &amp;default adapter: postgresql encoding: unicode pool: &lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;) { 5 } %&gt; timeout: 5000 host: postgres port: 5432 username: &lt;%= ENV[&#39;DATABASE_USERNAME&#39;] %&gt; password: &lt;%= ENV[&#39;DATABASE_PASSWORD&#39;] %&gt; development: &lt;&lt;: *default database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; # Warning: The database defined as &#34;test&#34; will be erased and # re-generated from your development database when you run &#34;rake&#34;. # Do not set this db to the same as development or production. test: &lt;&lt;: *default database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; production: &lt;&lt;: *default database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; git diff - # SQLite. Versions 3.8.0 and up are supported. - # gem install sqlite3 - # - # Ensure the SQLite 3 gem is defined in your Gemfile - # gem &#34;sqlite3&#34; - # default: &amp;default - adapter: sqlite3 + adapter: postgresql + encoding: unicode pool: &lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;) { 5 } %&gt; timeout: 5000 + host: postgres + port: 5432 + username: &lt;%= ENV[&#39;DATABASE_USERNAME&#39;] %&gt; + password: &lt;%= ENV[&#39;DATABASE_PASSWORD&#39;] %&gt; development: &lt;&lt;: *default - database: db/development.sqlite3 + database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; # Warning: The database defined as &#34;test&#34; will be erased and # re-generated from your development database when you run &#34;rake&#34;. # Do not set this db to the same as development or production. test: &lt;&lt;: *default - database: db/test.sqlite3 + database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; production: &lt;&lt;: *default - database: db/production.sqlite3 + database: &lt;%= ENV[&#39;DATABASE_DB_NAME&#39;] %&gt; In the above configuration, we connect to Postgres with hostname postgres (because we run in the internal Docker network).
Lastly, to ensure we already install and connected with to Postgres, we can run the Docker run command again:
docker compose up --build --force-recreate Now, try to access or hard refresh http://localhost:3000 again, it should still return the Rails homepage as shown in Figure 2 above.
You can see all these changes in this section here: 853fda5
Creating Users Table and Connecting Using Active Record # In the terminal run this command to create a database migration files:
docker compose run --no-deps myapp rails generate migration EnableUUIDExt And
docker compose run --no-deps myapp rails generate migration CreateUsersTable You will get two new files:
db/migrate/20230228035405_enable_uuid_ext.rb db/migrate/20230228035420_create_users_table.rb Please note that the prefix value (20230228035405 or 20230228035420) is the current timestamp when you run the command. You don&rsquo;t need to be careful of that, because the important things is the file content.
In the db/migrate/20230228035405_enable_uuid_ext.rb replace the file content with this:
class EnableUuidExt &lt; ActiveRecord::Migration[7.0] def change enable_extension &#34;uuid-ossp&#34; end end This will tell Rails to create a uuid-ossp extensions, similar like we run this query:
CREATE EXTENSION IF NOT EXISTS &#34;uuid-ossp&#34;; And in the file db/migrate/20230228035420_create_users_table.rb replace the file content to this:
class CreateUsersTable &lt; ActiveRecord::Migration[7.0] def up create_table :users, :id =&gt; false do |t| t.column :id, &#39;uuid&#39;, :null =&gt; false, :primary_key =&gt; true, :default =&gt; &#34;uuid_generate_v4()&#34; t.string :username, :null =&gt; false t.string :name, :null =&gt; false, :default =&gt; &#39;&#39; t.timestamps end add_index :users, :username, unique: true end def down drop_table :users end end Then run this command in the terminal to create the table in Postgres database:
docker compose run --no-deps myapp rails db:migrate You will get the output similar like this:
Figure 3. Database Migration For Users Table To verify that our database migration is applied in our Postgres container, run this command:
docker compose run --no-deps postgres psql -U root -h postgres rails_otel_dev Type the password which is password, then run command \\d inside it. We will see that we now have 3 tables:
ar_internal_metadata schema_migrations users docker compose run --no-deps postgres psql -U root -h postgres rails_otel_dev Password for user root: psql (15.2 (Debian 15.2-1.pgdg110+1)) Type &#34;help&#34; for help. rails_otel_dev=# \\d List of relations Schema | Name | Type | Owner --------+----------------------+-------+------- public | ar_internal_metadata | table | root public | schema_migrations | table | root public | users | table | root (3 rows) rails_otel_dev=# You can see all these changes in this section here: c707a25
Creating Services, JWT encoder/decoder, and Controller # In this section, I will go straightforward of what code we need to write. This is because the article already long enough, and we still don&rsquo;t get to the main part where we should change our log output to get better observability. So, I may not write long explanation about what the code is doing, and just put the file name and code.
Now, we need to create model to interact with our table in file app/models/user.rb:
class User &lt; ApplicationRecord end This is for Rails application to interact with the users table we create before.
Then create a file in app/externals/promotions/promotion_service.rb:
module Promotions class PromotionService def self.list_vouchers() # random sleep from 100ms to 500ms s = (rand(100...500).to_f/1000).to_f # divide by 1000 to get millisecond Rails.logger.debug &#34;PromotionService.list_vouchers call started&#34; sleep(s) Rails.logger.debug &#34;PromotionService.list_vouchers done&#34; return [ [ &#39;voucher_code&#39; =&gt; &#39;REGISTER_ANNIVERSARY&#39;, &#39;description&#39; =&gt; &#39;will get 5% discount if user is a loyal users (already joined minimum 1 year)&#39;, &#39;terms_and_conditions&#39;: [ &#39;discount&#39; =&gt; 5, &#39;min_registered_year&#39; =&gt; 1, &#39;registered_date_is_same&#39; =&gt; true, &#39;registered_month_is_same&#39; =&gt; true, &#39;name_prefix&#39; =&gt; &#34;&#34;, ] ], [ &#39;voucher_code&#39; =&gt; &#39;I_AM_JAN&#39;, &#39;description&#39; =&gt; &#34;will get 1% discount if user have name prefix &#39;jan&#39; because our app is launched at January!&#34;, &#39;terms_and_conditions&#39;: [ &#39;discount&#39; =&gt; 1, &#39;min_registered_year&#39; =&gt; 0, &#39;registered_date_is_same&#39; =&gt; false, &#39;registered_month_is_same&#39; =&gt; false, &#39;name_prefix&#39; =&gt; &#34;&#34;, ] ] ] end end end This to mimicking external service that we need to call via network (either HTTP or gRPC, and that&rsquo;s the reason why I put it under app/externals directory). Supposed that we designed our system using microservice architecture, we may split into several separated service and we call it from main application. But, instead writing some real another service and call it, in this section I write a hard-coded object in class PromotionService that mimicking the response of the Promotions service when we request list of voucher code. Since this code will never return error, I added some sleep operation mimicking the network call latency and some logger before and after it.
Now, create another file app/services/vouchers/user_voucher.rb that do the main business logic:
Get user information from database Call the PromotionService above and return the user object and list of vouchers. module Vouchers class UserVoucher def self.vouchers(user_id) Rails.logger.debug &#34;reaching business logic&#34; Rails.logger.debug &#34;doing query get user by id #{user_id}&#34; user = User::find_by(:id =&gt; user_id) throw :NotFoundUser if user.nil? Rails.logger.debug &#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers #{user_id}&#34; vouchers = Promotions::PromotionService::list_vouchers() return [ &#39;user&#39; =&gt; user, &#39;vouchers&#39; =&gt; vouchers ] end end end Now, we need to create a library for encoding and decoding the Json Web Token. To do that, we need to install some gem in our Gemfile:
53 + 54 # A pure ruby implementation of the RFC 7519 OAuth JSON Web Token (JWT) standard. + 55 gem &#39;jwt&#39;, &#39;~&gt; 2.7&#39; + 56 We install library jwt to decode and encode the JWT.
Then create a file lib/json_web_token.rb:
class JsonWebToken def self.encode(payload) return JWT.encode(payload, Rails.application.secrets.secret_key_base) end def self.decode(token) Rails.logger.debug &#34;validating JWT&#34; return JWT.decode(token, Rails.application.secrets.secret_key_base) rescue nil end end Now, let&rsquo;s create the controller and route for it.
We need add library responders since we need respond_to method that are no longer a part of Rails. In Gemfile add this line:
+ 56 + 57 # A set of Rails responders to dry up your application + 58 gem &#39;responders&#39;, &#39;~&gt; 3.1&#39; + 59 Then change the file app/controllers/application_controller.rb into this to register the function loaded in controllers.
1 class ApplicationController &lt; ActionController::Base + 2 include ActionController::MimeResponds 3 end 4 After that, create the controller file app/controllers/UserPromotionController.rb:
require_dependency &#34;json_web_token&#34; class UserPromotionController &lt; ApplicationController def list_vouchers Rails.logger.debug &#34;request accepted by controller&#34; begin token = &#34;&#34; auth = request.headers[&#39;Authorization&#39;] if !auth.nil? token = auth.split(&#39; &#39;).last end if token.empty? Rails.logger.debug &#34;accepting token from query params&#34; token = request.query_parameters[&#39;token&#39;] else Rails.logger.debug &#34;accepting token from headers&#34; end token_extracted = JsonWebToken::decode(token) if token_extracted.nil? || token_extracted.to_a.length() &lt;= 0 return respond_to do |format| format.any {render :json =&gt; [ &#39;message&#39; =&gt; &#39;nil extracted token&#39; ]} end end jwt_payload = token_extracted[0] if jwt_payload.nil? return respond_to do |format| format.any {render :json =&gt; [ &#39;message&#39; =&gt; &#39;nil jwt payload&#39; ]} end end user_id = jwt_payload[&#39;user_id&#39;] if user_id.nil? || user_id.empty? return respond_to do |format| format.any {render :json =&gt; [ &#39;message&#39; =&gt; &#39;empty user id from jwt payload&#39; ]} end end out = Vouchers::UserVoucher::vouchers(user_id) Rails.logger.debug &#34;controller done processing the request, preparing rendering response&#34; return respond_to do |format| format.any {render :json =&gt; out} end rescue =&gt; err return respond_to do |format| format.any {render :json =&gt; [ &#39;message&#39;: err ]} end end # end of begin-rescue end end Now, we have our controller that accept token (JWT) via header or query params token, then encode it using JsonWebToken::decode(token) that we create in lib/json_web_token.rb to get the user_id. After that we pass this user_id to UserVoucher::vouchers(user_id) which we defined in app/services/vouchers/user_voucher.rb.
But, this controller cannot be accessed until we register the routes.
Registering Routes # First, we need to make sure all our previous code loaded by Rails by adding this line in config/application.rb:
config.watchable_dirs[&#39;lib&#39;] = [:rb] Then register our controller in config/routes.rb:
get &#39;list-vouchers&#39;, to: &#39;user_promotion#list_vouchers&#39; Done! Please re-run the command docker compose up --build --force-recreate again. It will install the library jwt and responders.
Now we have the routes that can be accessed http://localhost:3000/list-vouchers?token=jwt.access.token. But, we don&rsquo;t have any real user saved in our Postgres and we don&rsquo;t have any JSON Web Token yet. Let&rsquo;s go to next section!
You can see changes in this section here: c85c199
Insert User data and Create JWT access token via rails console # We can invoke and run any code of our code by launching the rails console. Since we are using Docker for our development tools, we can run rails console inside the container:
docker compose run --no-deps myapp rails console Then, to insert the User with username jane and name Jane Kepiye Karepe To we can run this code inside the rails console launched by previous command:
User::create(username: &#34;jane&#34;, name: &#34;Jane Kepiye Karepe To&#34;) Then continue with running this command to get the previous inserted user and generate JWT token:
Note: run this line by line.
u = User::find_by(username: &#34;jane&#34;) require_dependency &#34;json_web_token&#34; token = JsonWebToken::encode({user_id: u.id}) You will get the output something like this:
Figure 4. Insert user and generate JWT In this example, you get the JWT token. Your generated token may be different, use your own token!
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 Accessing the routes # You can access the page http://localhost:3000/list-vouchers?token={your-token} which will return the JSON similar as shown in figure 5.
Figure 5. Route /list-vouchers Finally, we have a single route Rails application in this part. Then, we can go to Part 2 to learn what the problem we have if we use this code in high traffic and how to improve it.
`}),e.add({id:2,href:"/blog/posts/2023-02-24-rails-otel-part2/",title:"Better Observability on Ruby on Rails Logs with OpenTelemetry Trace and Span ID (Part 2 - Improving Log Output)",section:"Blog",content:`In previous part you already know how to setup a simple (really simple) Rails application with one route. In this part, I will focusing on how we improve the log printed by the standard Rails application.
To recap, if you want to follow this article smoothly, you can use the code from previous part by cloning from my Github repository:
git clone https://github.com/yusufsyaifudin/rails-otel.git And then checkout to the commit id c85c199 where is the last state of the code from previous article.:
git checkout c85c199c3a46ddb0a245f4ccd340bf5850fa17dd As we already saw in the introduction article, when we&rsquo;re running the Rails application, at default it will print the log output that look like this:
myapp | Started GET &#34;/list-vouchers&#34; for 192.168.32.1 at 2023-03-09 03:26:00 +0000 myapp | Cannot render console from 192.168.32.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1 myapp | ActiveRecord::SchemaMigration Pluck (1.8ms) SELECT &#34;schema_migrations&#34;.&#34;version&#34; FROM &#34;schema_migrations&#34; ORDER BY &#34;schema_migrations&#34;.&#34;version&#34; ASC myapp | Processing by UserPromotionController#list_vouchers as HTML myapp | request accepted by controller myapp | accepting token from headers myapp | validating JWT myapp | reaching business logic myapp | doing query get user by id c8c6991c-687e-44cc-8755-4743ef66d265 myapp | User Load (2.2ms) SELECT &#34;users&#34;.* FROM &#34;users&#34; WHERE &#34;users&#34;.&#34;id&#34; = $1 LIMIT $2 [[&#34;id&#34;, &#34;c8c6991c-687e-44cc-8755-4743ef66d265&#34;], [&#34;LIMIT&#34;, 1]] myapp | â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39; myapp | calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265 myapp | PromotionService.list_vouchers call started myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 314ms (Views: 12.1ms | ActiveRecord: 9.0ms | Allocations: 8720) Give Traffics to Rails Application # Before we breaking down the problems that we may have in default Rails app, we need to make sure we have enough traffic to mock the high traffic that we may face in production. To do that, we need more than 1 users and concurrent access to our routes.
Preparing the data # First, let us create 100 users, using rails console:
docker compose run --no-deps myapp rails console Note:
Before you run this command, you need to make sure that the Rails application is active by running docker compose up --build --force-recreate in separate terminal.
Then, inside rails console run this command to insert 100 users at once:
for counter in 1..100 do User::create(username: &#34;user#{counter}&#34;, name: &#34;User #{counter}&#34;) end Above command will insert 100 user. Now, let&rsquo;s create a JSON Web Token (JWT) on each user:
require_dependency &#34;json_web_token&#34; tokens = [] for counter in 1..100 do username = &#34;user#{counter}&#34; token = JsonWebToken.encode({ user_id: User.find_by(username: username).id }) tokens.push({username: username, token: token}) end Dir.mkdir(&#34;scripts&#34;) unless Dir.exist?(&#34;scripts&#34;) Dir.mkdir(&#34;scripts/loadtest&#34;) unless Dir.exist?(&#34;scripts/loadtest&#34;) File.open(&#34;scripts/loadtest/tokens.json&#34;, &#39;w&#39;) {|f| f.write(tokens.to_json) } This will create a file scripts/k6/tokens.json which contain a list of token and username in JSON array (in minified version) as follows:
[ { &#34;username&#34;: &#34;user1&#34;, &#34;token&#34;: &#34;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiNmI4NzUyMWEtMTJhOC00MGUxLTkxZDEtYTU3YzAxZDM5N2YwIn0.Zpw7sm-SCW6lROcfU0CB3oOe1Fjsg5REDKCnNTfHkAk&#34; } ] Generate Traffic Using k6 Load Testing # First, we need to install k6 by following this instruction https://k6.io/docs/get-started/installation/ or using Docker.
Then, create a file scripts/loadtest/list-vouchers.js:
import { check } from &#39;k6&#39;; import { Counter } from &#39;k6/metrics&#39;; import http from &#39;k6/http&#39;; import { uuidv4 } from &#39;https://jslib.k6.io/k6-utils/1.4.0/index.js&#39;; const successCounter = new Counter(&#39;success_counter&#39;); const failedCounter = new Counter(&#39;failed_counter&#39;); const payloads = JSON.parse(open(&#39;/scripts/loadtest/tokens.json&#39;)); const randomIndex = Math.floor(Math.random() * payloads.length); const payload = payloads[randomIndex]; export default function () { const params = { headers: { &#39;X-Request-ID&#39;: uuidv4(), Authorization: payload.token, }, }; const serviceURL = __ENV.SERVICE_URL; const resp = http.get(serviceURL+&#39;/list-vouchers&#39;, params); check(resp, { &#39;status is 200&#39;: (r) =&gt; r.status === 200, &#39;response contains expected username&#39;: (r) =&gt; r.json().user.username=== payload.username, }); if (resp.status === 200) { successCounter.add(1); } else { failedCounter.add(1); } }import { check } from &#39;k6&#39;; import { Counter } from &#39;k6/metrics&#39;; import http from &#39;k6/http&#39;; import { uuidv4 } from &#39;https://jslib.k6.io/k6-utils/1.4.0/index.js&#39;; const successCounter = new Counter(&#39;success_counter&#39;); const failedCounter = new Counter(&#39;failed_counter&#39;); const payloads = JSON.parse(open(&#39;/scripts/loadtest/tokens.json&#39;)); const randomIndex = Math.floor(Math.random() * payloads.length); const payload = payloads[randomIndex]; export default function () { const params = { headers: { &#39;X-Request-ID&#39;: uuidv4(), Authorization: payload.token, }, }; const serviceURL = __ENV.SERVICE_URL; const resp = http.get(serviceURL+&#39;/list-vouchers&#39;, params); check(resp, { &#39;contains expected username&#39;: (r) =&gt; r.status === 200 &amp;&amp; r.json().user.username=== payload.username, }); if (resp.status === 200) { successCounter.add(1); } else { failedCounter.add(1); } } Now, run this command to do only one request using K6 Docker:
Don&rsquo;t forget to use --net=host to make sure Docker access &ldquo;localhost&rdquo; to your Host machine
cat scripts/loadtest/list-vouchers.js | docker run \\ -e SERVICE_URL=http://localhost:3000 \\ -v $(pwd)/scripts/loadtest/tokens.json:/scripts/loadtest/tokens.json:ro \\ --net=host --platform linux/amd64 --rm -i grafana/k6:0.43.1 run - If it runs with no issues, you will look the result like this:
SERVICE_URL=http://localhost:3000 AUTH_TOKEN=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 k6 run scripts/loadtest/list-vouchers.js /\\ |â€¾â€¾| /â€¾â€¾/ /â€¾â€¾/ /\\ / \\ | |/ / / / / \\/ \\ | ( / â€¾â€¾\\ / \\ | |\\ \\ | (â€¾) | / __________ \\ |__| \\__\\ \\_____/ .io execution: local script: scripts/loadtest/list-vouchers.js output: - scenarios: (100.00%) 1 scenario, 1 max VUs, 10m30s max duration (incl. graceful stop): * default: 1 iterations for each of 1 VUs (maxDuration: 10m0s, gracefulStop: 30s) data_received..................: 1.4 kB 1.5 kB/s data_sent......................: 242 B 265 B/s http_req_blocked...............: avg=30.69ms min=30.69ms med=30.69ms max=30.69ms p(90)=30.69ms p(95)=30.69ms http_req_connecting............: avg=146Âµs min=146Âµs med=146Âµs max=146Âµs p(90)=146Âµs p(95)=146Âµs http_req_duration..............: avg=877.07ms min=877.07ms med=877.07ms max=877.07ms p(90)=877.07ms p(95)=877.07ms { expected_response:true }...: avg=877.07ms min=877.07ms med=877.07ms max=877.07ms p(90)=877.07ms p(95)=877.07ms http_req_failed................: 0.00% âœ“ 0 âœ— 1 http_req_receiving.............: avg=626Âµs min=626Âµs med=626Âµs max=626Âµs p(90)=626Âµs p(95)=626Âµs http_req_sending...............: avg=491Âµs min=491Âµs med=491Âµs max=491Âµs p(90)=491Âµs p(95)=491Âµs http_req_tls_handshaking.......: avg=0s min=0s med=0s max=0s p(90)=0s p(95)=0s http_req_waiting...............: avg=875.95ms min=875.95ms med=875.95ms max=875.95ms p(90)=875.95ms p(95)=875.95ms http_reqs......................: 1 1.095911/s iteration_duration.............: avg=912.13ms min=912.13ms med=912.13ms max=912.13ms p(90)=912.13ms p(95)=912.13ms iterations.....................: 1 1.095911/s success_counter................: 1 1.095911/s running (00m00.9s), 0/1 VUs, 1 complete and 0 interrupted iterations default âœ“ [======================================] 1 VUs 00m00.9s/10m0s 1/1 iters, 1 per VU Figure 1. Run Simple K6 Command And the Rails log output will look like this:
myapp | Started GET &#34;/list-vouchers&#34; for 192.168.32.1 at 2023-03-09 03:26:00 +0000 myapp | Cannot render console from 192.168.32.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1 myapp | ActiveRecord::SchemaMigration Pluck (1.8ms) SELECT &#34;schema_migrations&#34;.&#34;version&#34; FROM &#34;schema_migrations&#34; ORDER BY &#34;schema_migrations&#34;.&#34;version&#34; ASC myapp | Processing by UserPromotionController#list_vouchers as HTML myapp | request accepted by controller myapp | accepting token from headers myapp | validating JWT myapp | reaching business logic myapp | doing query get user by id c8c6991c-687e-44cc-8755-4743ef66d265 myapp | User Load (2.2ms) SELECT &#34;users&#34;.* FROM &#34;users&#34; WHERE &#34;users&#34;.&#34;id&#34; = $1 LIMIT $2 [[&#34;id&#34;, &#34;c8c6991c-687e-44cc-8755-4743ef66d265&#34;], [&#34;LIMIT&#34;, 1]] myapp | â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39; myapp | calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265 myapp | PromotionService.list_vouchers call started myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 314ms (Views: 12.1ms | ActiveRecord: 9.0ms | Allocations: 8720) myapp | myapp | Figure 2. Rails Logging Output With One Request At this point, we already have a working Rails app that show the default log output format. In the next section, I will show you what we can improve with the log output.
You can see changes in this section (adding k6 load testing script) here: 3548129
Breaking down the problem # In the Introduction I quoted the ChatGPT responses on &ldquo;why rails app log hard to debug&rdquo;.
In this section, I will give some proof of the statements.
From the previous section, lets we do more request using k6 with 10 VUs (Virtual Users) for 10 seconds:
cat scripts/loadtest/list-vouchers.js | docker run \\ -e SERVICE_URL=http://localhost:3000 \\ -v $(pwd)/scripts/loadtest/tokens.json:/scripts/loadtest/tokens.json:ro \\ --net=host --platform linux/amd64 --rm -i grafana/k6:0.43.1 run --vus 10 --duration 10s - As we can see in Figure 3, we already give our Rails app with 164 requests (you can see in the iterations in the Figure 3). This number may different each time you run the k6 load testing, it depends on multi-factor.
iterations.....................: 164 14.951436/s Figure 3. K6 Output With 100VUs for 10s In Figure 4 below, we can see that the Rails logger now is harder to read.
Figure 4. Rails Log Output Become Hard To Read Rails Log Output Become Hard To Read myapp | Processing by UserPromotionController#list_vouchers as HTML myapp | request accepted by controller myapp | accepting token from headers myapp | validating JWT myapp | reaching business logic myapp | doing query get user by id dd2865e6-4529-44c3-b475-f3cfa3eb6551 myapp | User Load (0.2ms) SELECT &#34;users&#34;.* FROM &#34;users&#34; WHERE &#34;users&#34;.&#34;id&#34; = $1 LIMIT $2 [[&#34;id&#34;, &#34;dd2865e6-4529-44c3-b475-f3cfa3eb6551&#34;], [&#34;LIMIT&#34;, 1]] myapp | â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39; myapp | calling PromotionService.list_vouchers from UserVoucher.list_vouchers dd2865e6-4529-44c3-b475-f3cfa3eb6551 myapp | PromotionService.list_vouchers call started myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 152ms (Views: 0.6ms | ActiveRecord: 0.7ms | Allocations: 5057) myapp | myapp | myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 139ms (Views: 0.4ms | ActiveRecord: 0.2ms | Allocations: 1649) myapp | myapp | myapp | Started GET &#34;/list-vouchers&#34; for 192.168.80.1 at 2023-03-09 09:32:28 +0000 myapp | Cannot render console from 192.168.80.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1 myapp | Processing by UserPromotionController#list_vouchers as HTML myapp | request accepted by controller myapp | accepting token from headers myapp | validating JWT myapp | reaching business logic myapp | doing query get user by id 99dca0af-84f2-4e9f-9925-66a5b6442c2a myapp | User Load (0.3ms) SELECT &#34;users&#34;.* FROM &#34;users&#34; WHERE &#34;users&#34;.&#34;id&#34; = $1 LIMIT $2 [[&#34;id&#34;, &#34;99dca0af-84f2-4e9f-9925-66a5b6442c2a&#34;], [&#34;LIMIT&#34;, 1]] myapp | â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39; myapp | calling PromotionService.list_vouchers from UserVoucher.list_vouchers 99dca0af-84f2-4e9f-9925-66a5b6442c2a myapp | PromotionService.list_vouchers call started myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 496ms (Views: 0.8ms | ActiveRecord: 0.4ms | Allocations: 11963) myapp | myapp | myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 371ms (Views: 0.7ms | ActiveRecord: 0.3ms | Allocations: 8049) myapp | myapp | myapp | PromotionService.list_vouchers done myapp | controller done processing the request, preparing rendering response myapp | Completed 200 OK in 319ms (Views: 1.8ms | ActiveRecord: 0.3ms | Allocations: 2298) myapp | myapp | Complexity and Volume # Rails applications can be complex with many layers of code that interact with each other. This can make it difficult to pinpoint the root cause of an issue.
As you can see in Figure 4, when we have high traffic, the Rails log become hard to read because some log may delayed to print, so we cannot see the right order of the logs line. If we adding the timestamp at the front of each log lines, we still cannot get the better understanding because it is uncommon to sorting the unstructured logs. See also #Lack of context.
Rails logs can generate a large volume of information, making it difficult to find the relevant information needed to debug an issue.
Also, since the we have a large volumes of log, we need a good tooling which can be easier to query and filter to show log that we need to see.
Lack of structure # Rails logs can lack structure, making it difficult to identify the relevant information needed to debug an issue.
Structured log is easier to query and makes developer easier to pin-point the issues. For example, the Customer Service got the complaint from User U at time T that the application become unresponsive. The Customer Service then can open the ticket and let the developer to see the log only for that user at that time. If we still have unstructured log as shown in Figure 4, how we can do that?
If we have a structured log, (let say JSON formatted), we can pipe all these logs into Elasticsearch and query it using Kibana (or renowned as ELK Stack. As an alternative, we can use Grafana Loki to query it from Cassandra or AWS DynamoDB. JSON is preferred because developers should familiar with that kind of format as it commonly used in REST API request/response payload.
Lack of context # Rails logs may not provide enough context to understand the flow of the application, making it difficult to understand how the different parts of the application are interacting.
At Figure 4, we see Completed 200 OK three times at the end of the logs. But, how can we know the previous process that related to this line? Why at first we got 496ms, then 371ms and then 319ms? If at some point we see the number is more than 10 seconds, how can we know the related log that causing the process took too long?
Lack of tooling # Traditional text editors or command line tools may not be well suited for analyzing logs, and dedicated log analysis tools can be expensive or require specialized knowledge.
As I mention in #Lack of structure, it is more easier to query using JSON that text. Even if we are only using terminal, with JSON we can do some query using jq or its alternative gojq. But, I do prefer if we save it into some persistent storage (with some TTL to reduce cost of storage) and query them via dashboard UI (like Grafana Loki or Kibana).
Refactoring Log Output To Structured Log # After we acknowledge that there is a problem with our Rails app, we can then try to improve our log starting with making it as JSON output per log line.
We will refactor our log output to JSON, with this minimal structure:
{ &#34;level&#34;: &#34;INFO&#34;, // Required. Level of the log: &#34;time&#34;: &#34;2023-03-13T09:07:48.639Z&#34;, // Required. Time when the log is written in RFC3339 Nano https://www.rfc-editor.org/rfc/rfc3339 &#34;msg&#34;: &#34;message of this log&#34;, // Required. &#34;trace_id&#34;: &#34;00000000000000000000000000000000&#34;, // Required. hex-encoded. &#34;span_id&#34;: &#34;0000000000000000&#34;, // Required. hex-encoded. &#34;trace_flags&#34;: &#34;00&#34;, // Required. formatted according to W3C traceflags format. &#34;node_id&#34;: &#34;8689d48b-d323-4492-a989-b9fb7f7ad81a&#34;, // Required. UUID string that will always the same from start to stop. If restart, this ID MUST be generated again, so we can detect that two logs is come from different restart count. &#34;progname&#34;: &#34;rails-otel&#34;, // Required. Service name that produce this log. This MUST contain lower-case and alphanumeric string only (dash or underscore is used as space replacement, no other character permitted). &#34;request_id&#34;: &#34;&#34;, // Optional. Only appeared when the log is triggered via request-response model API (HTTP, gRPC, or anything) &#34;attributes&#34;: [{&#34;key&#34;: &#34;value&#34;}], // Optional. Contains Array of object (key-value) format,, &#34;data&#34;: {} // Optional, can contain array or anything depend on the log you want to write. } Change the Booting Output # Since in booting process we cannot get any information regarding the
Add this line into file config/boot.rb:
require &#39;securerandom&#39; require &#34;rails/command&#34; # Allow for base class autoload require &#34;rails/commands/server/server_command&#34; # Load the ServerCommand class RAILS_NODE_ID = SecureRandom.uuid PROGRAM_NAME = ENV[&#39;PROGRAM_NAME&#39;] || &#39;no-service-name&#39; # https://stackoverflow.com/a/75651939 Rails::Command::ServerCommand.class_eval do # print_boot_information override the original method to make all log turn into JSON # https://github.com/rails/rails/blob/7c70791470fc517deb7c640bead9f1b47efb5539/railties/lib/rails/commands/server/server_command.rb#L278-L284 # 7c70791 is commit hash for release tag: https://github.com/rails/rails/releases/tag/v7.0.4.2 # If you have different version of Rails, this method may not work! def print_boot_information(server, url) logs = [ &#34;Booting #{ActiveSupport::Inflector.demodulize(server)}&#34;, &#34;Rails #{Rails.version} application starting in #{Rails.env} #{url}&#34;, &#34;Run \`bin/rails server --help\` for more startup options&#34; ] ts = Time.now logs.each do |log| json_log = { level: &#34;UNKNOWN&#34;, time: ts, msg: log, trace_id: &#39;00000000000000000000000000000000&#39;, span_id: &#39;0000000000000000&#39;, trace_flags: &#39;00&#39;, node_id: RAILS_NODE_ID, progname: PROGRAM_NAME, }.to_json STDOUT.puts(json_log) end end end Then, as we are using Puma as our server, we need to configure Puma log output into JSON by adding these line in the file config/puma.rb:
# Use JSON format for booting logs ts = Time.now log_formatter do |str| line = { level: &#34;UNKNOWN&#34;, time: ts, msg: str.delete_prefix(&#39;*&#39;).chomp().strip(), trace_id: &#39;00000000000000000000000000000000&#39;, span_id: &#39;0000000000000000&#39;, trace_flags: &#39;00&#39;, node_id: RAILS_NODE_ID, progname: PROGRAM_NAME, }.to_json STDOUT.puts(line) end You may notice that we add global constant PROGRAM_NAME by getting its value from environment variable ENV['PROGRAM_NAME'], so we need to add the environment variable to docker-compose.yml:
16 environment: 17 DATABASE_USERNAME: root 18 DATABASE_PASSWORD: password 19 DATABASE_DB_NAME: rails_otel_dev + 20 PROGRAM_NAME: &#39;rails-otel&#39; 21 Now, restart the server by running:
docker compose up --build --force-recreate VoilÃ , you&rsquo;ll see that now our log become structured JSON.
Figure 5. Rails now produces JSON on booting {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.733+00:00&#34;,&#34;msg&#34;:&#34;Booting Puma&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.733+00:00&#34;,&#34;msg&#34;:&#34;Rails 7.0.4.2 application starting in development &#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.733+00:00&#34;,&#34;msg&#34;:&#34;Run \`bin/rails server --help\` for more startup options&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Puma starting in single mode...&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Puma version: 5.6.5 (ruby 3.2.1-p31) (\\&#34;Birdie&#39;s Version\\&#34;)&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Min threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Max threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Environment: development&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;PID: 1&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Listening on http://0.0.0.0:3000&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-13T09:47:13.983+00:00&#34;,&#34;msg&#34;:&#34;Use Ctrl-C to stop&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;5d5d3085-89f7-4374-bea7-a22445d5a770&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} Changes on this section can be seen at this commit 21a4666.
Add OpenTelemetry SDK # Before configuring the rest of logger to JSON, we need to add OpenTelemetry to get the actual trace_id and span_id. This is the advantages using OpenTelemetry SDK:
We don&rsquo;t need to re-invent the wheel on how ID should be generated and formatted. If we have enough budget, we can deploy Jaeger or Grafana or using provider such as DataDog or NewRelic to see our app trace. Then we can also correlate logs and traces with the same trace_id. But, if we don&rsquo;t have enough resources (either human resource or infrastructure), we can disable OpenTelemetry to push and just use the SDK itself to generate. First, we need to install OpenTelemetry Gem SDK:
+ 60 # A stats collection and distributed tracing framework + 61 gem &#39;opentelemetry-sdk&#39;, &#39;1.2&#39; + 62 + 63 # OTLP exporter for the OpenTelemetry framework + 64 gem &#39;opentelemetry-exporter-otlp&#39;, &#39;0.24.0&#39; + 65 + 66 # All-in-one instrumentation bundle for the OpenTelemetry framework + 67 # Provides instrumentations for Rails, Sinatra, several HTTP libraries, and more. + 68 gem &#39;opentelemetry-instrumentation-all&#39;, &#39;0.31.0&#39; + 69 Then, create a file config/initializers/opentelemetry.rb with following code:
require &#39;opentelemetry/sdk&#39; require &#39;opentelemetry/exporter/otlp&#39; require &#39;opentelemetry/instrumentation/all&#39; # Custom exporter to make print to STDOUT class MyExporter &lt; OpenTelemetry::Exporter::OTLP::Exporter # Override function here: # https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/exporter/otlp/lib/opentelemetry/exporter/otlp/exporter.rb#L79-L90 def export(span_data, timeout: nil) # Custom logic for exporting data goes here STDOUT.puts(&#34;Exporting data: #{span_data.inspect}&#34;) return OpenTelemetry::SDK::Trace::Export::SUCCESS end end # Exporter and Processor configuration # See list of arguments here https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/exporter/otlp/lib/opentelemetry/exporter/otlp/exporter.rb#L48-L54 # As of March 15th, 2023, the gRPC exporter is not published to Rubygems and marked as not production ready. # See https://github.com/open-telemetry/opentelemetry-ruby/issues/1337 # So, we can only use HTTP for now. OTEL_EXPORTER = OpenTelemetry::Exporter::OTLP::Exporter.new( endpoint: ENV[&#39;OTEL_EXPORTER_OTLP_ENDPOINT&#39;], ) # Use this custom exporter if we want to log into STDOUT only, or implement another exporter (such as no-operation). # OTEL_EXPORTER = MyExporter.new() # See https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/sdk/lib/opentelemetry/sdk/trace/export/batch_span_processor.rb#L47-L53 processor = OpenTelemetry::SDK::Trace::Export::BatchSpanProcessor.new(OTEL_EXPORTER) OpenTelemetry::SDK.configure do |c| c.resource = OpenTelemetry::SDK::Resources::Resource.create({ OpenTelemetry::SemanticConventions::Resource::SERVICE_NAMESPACE =&gt; &#39;rails-app&#39;, OpenTelemetry::SemanticConventions::Resource::SERVICE_NAME =&gt; PROGRAM_NAME.to_s, # Global variable PROGRAM_NAME already defined in config/boot.rb OpenTelemetry::SemanticConventions::Resource::SERVICE_INSTANCE_ID =&gt; Socket.gethostname(), OpenTelemetry::SemanticConventions::Resource::SERVICE_VERSION =&gt; &#34;0.0.0&#34;, # we can get it from environment variable }) # enables all instrumentation! c.use_all() # Or, if you prefer to filter specific instrumentation, # you can pick some of them like this https://scoutapm.com/blog/configuring-opentelemetry-in-ruby ##### Instruments # c.use &#39;OpenTelemetry::Instrumentation::Rack&#39; # c.use &#39;OpenTelemetry::Instrumentation::ActionPack&#39; # c.use &#39;OpenTelemetry::Instrumentation::ActionView&#39; # c.use &#39;OpenTelemetry::Instrumentation::ActiveJob&#39; # c.use &#39;OpenTelemetry::Instrumentation::ActiveRecord&#39; # c.use &#39;OpenTelemetry::Instrumentation::ConcurrentRuby&#39; # c.use &#39;OpenTelemetry::Instrumentation::Faraday&#39; # c.use &#39;OpenTelemetry::Instrumentation::HttpClient&#39; # c.use &#39;OpenTelemetry::Instrumentation::Net::HTTP&#39; # c.use &#39;OpenTelemetry::Instrumentation::PG&#39;, { # # By default, this instrumentation includes the executed SQL as the \`db.statement\` # # semantic attribute. Optionally, you may disable the inclusion of this attribute entirely by # # setting this option to :omit or sanitize the attribute by setting to :obfuscate # db_statement: :obfuscate, # } # c.use &#39;OpenTelemetry::Instrumentation::Rails&#39; # c.use &#39;OpenTelemetry::Instrumentation::Redis&#39; # c.use &#39;OpenTelemetry::Instrumentation::RestClient&#39; # c.use &#39;OpenTelemetry::Instrumentation::RubyKafka&#39; # c.use &#39;OpenTelemetry::Instrumentation::Sidekiq&#39; # Set OpenTelemetry library logger c.logger = Logger.new(STDOUT) # Exporter and Processor configuration c.add_span_processor(processor) end # &#39;MyAppTracer&#39; can be used throughout your code now MyAppTracer = OpenTelemetry.tracer_provider.tracer(PROGRAM_NAME, &#39;0.0.0&#39;) In above code, we are using HTTP to send the trace data to OpenTelemetry. But, if you wish to not send it, we can only print it (or entirely disable it) by using custom OpenTelemetry exporter MyExporter and change the exporter to OTEL_EXPORTER = MyExporter.new().
Then, don&rsquo;t forget to shutdown the OpenTelemetry exporter during app shutdown.
In file config/application.rb, add this following line:
+ 23 + 24 # Add a callback to shut down the OpenTelemetry exporter and SDK + 25 config.after_initialize do + 26 at_exit do + 27 OTEL_EXPORTER.shutdown + 28 end + 29 end + 30 Now, we have OpenTelemetry SDK installed. Next, we need to use OpenTelemetry Collector as agent to receives the traces produced by our app and Jaeger as the dashboard. To do that, we can add this service in our docker-compose.yaml:
jaeger: image: jaegertracing/all-in-one:1 container_name: jaeger restart: always command: - &#39;--collector.otlp.enabled=true&#39; ports: - &#34;5775:5775/udp&#34; - &#34;6831:6831/udp&#34; - &#34;6832:6832/udp&#34; - &#34;5778:5778&#34; - &#34;16686:16686&#34; # dashboard - &#34;14268:14268&#34; # Accepts spans directly from clients in jaeger.thrift format with binary thrift protocol (POST to /api/traces). Also serves sampling policies at /api/sampling, similar to Agentâ€™s port 5778. - &#34;9411:9411&#34; # Accepts Zipkin spans in Thrift, JSON and Proto (disabled by default). - &#34;14269:14269&#34; # Admin port: health check at / and metrics at /metrics. - &#34;14317:4317&#34; # gRPC Accepts traces in OpenTelemetry OTLP format if --collector.otlp.enabled=true. - &#34;14318:4318&#34; # HTTP Accepts traces in OpenTelemetry OTLP format if --collector.otlp.enabled=true. - &#34;14250:14250&#34; # Used by jaeger-agent to send spans in model.proto format. # Collector otel-collector: image: otel/opentelemetry-collector:0.69.0 container_name: otel-collector command: [ &#34;--config=/etc/otel-collector-config.yaml&#34; ] volumes: - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml:ro - ./docker-data/otel-collector/log:/tmp/log ports: - &#34;1888:1888&#34; # pprof extension - &#34;8888:8888&#34; # Prometheus&#39; metrics exposed by the collector - &#34;8889:8889&#34; # Prometheus exporter metrics - &#34;13133:13133&#34; # health_check extension - &#34;4317:4317&#34; # OTLP gRPC receiver - &#34;4318:4318&#34; # OTLP http receiver - &#34;55679:55679&#34; # zpages extension depends_on: - jaeger Then, still in our docker-compose.yaml, we need to add jaeger as our app dependency and OTEL_EXPORTER_OTLP_ENDPOINT variable.
14 depends_on: 15 - postgres +16 - jaeger 17 environment: 18 DATABASE_USERNAME: root 19 DATABASE_PASSWORD: password 20 DATABASE_DB_NAME: rails_otel_dev 21 PROGRAM_NAME: &#39;rails-otel&#39; +22 OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4318 # via HTTP 23 As we need a file otel-collector-config.yaml to configure OpenTelemetry Collector, we need to create that file in our app root directory otel-collector-config.yaml:
receivers: # Data sources: traces, metrics, logs otlp: protocols: http: cors: allowed_origins: - &#34;http://*&#34; - &#34;https://*&#34; processors: batch: {} exporters: # Data sources: traces jaeger: endpoint: &#34;jaeger:14250&#34; # point to jaeger-agent to send spans in model.proto format. tls: insecure: true # Data sources: traces, metrics, logs logging: verbosity: detailed sampling_initial: 5 sampling_thereafter: 200 # Data sources: traces, metrics, logs file: path: /tmp/log/otel-log.json service: pipelines: traces: receivers: [otlp] processors: [ batch ] exporters: [jaeger, logging, file] The OpenTelemetry should have properly configured, now we can restart our service and let Docker to pull the jaegertracing/all-in-one:1 and otel/opentelemetry-collector:0.69.0 images.
docker compose up --build --force-recreate We will see the log like this:
Figure 6. Rails Logger After Installing OpenTelemetry SDK Rails Logger After Installing OpenTelemetry SDK myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.293+00:00&#34;,&#34;msg&#34;:&#34;Booting Puma&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.293+00:00&#34;,&#34;msg&#34;:&#34;Rails 7.0.4.2 application starting in development &#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.293+00:00&#34;,&#34;msg&#34;:&#34;Run \`bin/rails server --help\` for more startup options&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | W, [2023-03-31T06:24:56.398800 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Trilogy failed to install myapp | I, [2023-03-31T06:24:56.399313 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ActiveSupport was successfully installed with the following options {} myapp | I, [2023-03-31T06:24:56.400173 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::Rack was successfully installed with the following options {:allowed_request_headers=&gt;[], :allowed_response_headers=&gt;[], :application=&gt;nil, :record_frontend_span=&gt;false, :retain_middleware_names=&gt;false, :untraced_endpoints=&gt;[], :url_quantization=&gt;nil, :untraced_requests=&gt;nil, :response_propagators=&gt;[]} myapp | I, [2023-03-31T06:24:56.403592 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ActionPack was successfully installed with the following options {} myapp | I, [2023-03-31T06:24:56.413223 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ActiveJob was successfully installed with the following options {:propagation_style=&gt;:link, :force_flush=&gt;false, :span_naming=&gt;:queue} myapp | I, [2023-03-31T06:24:56.498900 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ActiveRecord was successfully installed with the following options {} myapp | I, [2023-03-31T06:24:56.499400 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ActionView was successfully installed with the following options {:disallowed_notification_payload_keys=&gt;[], :notification_payload_transform=&gt;nil} myapp | W, [2023-03-31T06:24:56.499417 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::AwsSdk failed to install myapp | W, [2023-03-31T06:24:56.499426 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Bunny failed to install myapp | W, [2023-03-31T06:24:56.499437 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::LMDB failed to install myapp | W, [2023-03-31T06:24:56.499445 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::HTTP failed to install myapp | W, [2023-03-31T06:24:56.499452 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Koala failed to install myapp | W, [2023-03-31T06:24:56.499459 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::ActiveModelSerializers failed to install myapp | I, [2023-03-31T06:24:56.499879 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::ConcurrentRuby was successfully installed with the following options {} myapp | W, [2023-03-31T06:24:56.499895 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Dalli failed to install myapp | W, [2023-03-31T06:24:56.499903 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::DelayedJob failed to install myapp | W, [2023-03-31T06:24:56.499911 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Ethon failed to install myapp | W, [2023-03-31T06:24:56.499934 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Excon failed to install myapp | W, [2023-03-31T06:24:56.499945 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Faraday failed to install myapp | W, [2023-03-31T06:24:56.499952 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::GraphQL failed to install myapp | W, [2023-03-31T06:24:56.499959 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::HttpClient failed to install myapp | W, [2023-03-31T06:24:56.499969 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Mongo failed to install myapp | W, [2023-03-31T06:24:56.499976 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Mysql2 failed to install myapp | I, [2023-03-31T06:24:56.500488 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::Net::HTTP was successfully installed with the following options {:untraced_hosts=&gt;[]} myapp | I, [2023-03-31T06:24:56.501739 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::PG was successfully installed with the following options {:peer_service=&gt;nil, :db_statement=&gt;:include} myapp | W, [2023-03-31T06:24:56.501754 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Que failed to install myapp | W, [2023-03-31T06:24:56.501761 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Racecar failed to install myapp | I, [2023-03-31T06:24:56.501785 #1] INFO -- : Instrumentation: OpenTelemetry::Instrumentation::Rails was successfully installed with the following options {} myapp | W, [2023-03-31T06:24:56.501794 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Rake failed to install myapp | W, [2023-03-31T06:24:56.501801 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Rdkafka failed to install myapp | W, [2023-03-31T06:24:56.501810 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Redis failed to install myapp | W, [2023-03-31T06:24:56.501817 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::RestClient failed to install myapp | W, [2023-03-31T06:24:56.501824 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Resque failed to install myapp | W, [2023-03-31T06:24:56.501833 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::RubyKafka failed to install myapp | W, [2023-03-31T06:24:56.501840 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Sidekiq failed to install myapp | W, [2023-03-31T06:24:56.501847 #1] WARN -- : Instrumentation: OpenTelemetry::Instrumentation::Sinatra failed to install myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Puma starting in single mode...&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Puma version: 5.6.5 (ruby 3.2.1-p31) (\\&#34;Birdie&#39;s Version\\&#34;)&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Min threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Max threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Environment: development&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;PID: 1&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Listening on http://0.0.0.0:3000&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-03-31T06:24:56.610+00:00&#34;,&#34;msg&#34;:&#34;Use Ctrl-C to stop&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;e18b8780-a516-4f60-91f7-cc341cac7850&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | Changes on this section can be seen at this commit 2c5eb6f.
Duck-typing the Ruby::Logger # In previous sub-section, we use Ruby::Logger as the OpenTelemetry SDK Logger. Since we use Ruby 3.2.1 in Gemfile, it should refer to this Ruby Logger.
So, we can actually duck-type the Ruby logger formatter class to format our log into JSON, by defining class and method argument same as in this source or in this commit.
To do that, create file config/logger_json.rb:
class Logger::Formatter def call(severity, time, program_name, message) json_log = { level: severity, time: time, msg: message, trace_id: &#39;00000000000000000000000000000000&#39;, span_id: &#39;0000000000000000&#39;, trace_flags: &#39;00&#39;, node_id: RAILS_NODE_ID, progname: program_name || PROGRAM_NAME, }.to_json STDOUT.puts(json_log) end end And in file config/boot.rb, add:
require_relative &#34;logger_json&#34; Now, if you recreate the Docker container, it will show all JSON log.
Changes on this section can be seen at this commit 52d0dca.
Duck-typing the Ruby ActiveRecord Logger # References of this section:
https://unfit-for.work/posts/2023/rails-structured-logging/ https://medium.com/gojekengineering/structured-logging-in-rails-75e9a8c5370b https://cbpowell.wordpress.com/2013/08/09/beautiful-logging-for-ruby-on-rails-4/ If we access the URL http://localhost:3000/list-vouchers?token={your-token} we still get the non-JSON formatted log. We need to duck typing the ActiveRecord::Logger too.
Write this file config/logger_active_record_json.rb:
require &#39;securerandom&#39; # Class ActiveSupport::Logger will duck-type the original ActiveSupport::Logger class class ActiveSupport::Logger def initialize(*args) super(*args) end # format_message will override the method format_message on Ruby class Logger here: # https://github.com/ruby/logger/blob/4e8d9e27fd3b8f916cd3b370b97359f67e02c4bb/lib/logger.rb#L742-L744 # 4e8d9e2 is the commit release of version https://github.com/ruby/logger/releases/tag/v1.5.3 # # This because ActiveSupport::Logger duck-typing (extends) class Logger as seen here # https://github.com/rails/rails/blob/7c70791470fc517deb7c640bead9f1b47efb5539/activesupport/lib/active_support/logger.rb#L8 # 7c70791 is commit id on release tag https://github.com/rails/rails/releases/tag/v7.0.4.2 # # format_message should return void, so we do return with no arguments # We print it as JSON. def format_message(severity, timestamp, progname, msg) # prepare log and print it log = format_json(severity, timestamp, progname, msg, nil) STDOUT.puts(log) return end # format_json will format *args as JSON structured format. # This function will return JSON, and not print it. # The format MUST the same as format_message except this has &#34;attributes&#34; key. # In Ruby, you can use the splat operator * to define a variadic argument, # which allows a method to accept an arbitrary number of arguments. To add type checking to a variadic argument, # you can use the syntax argname : Type*. def format_json(severity, time, progname, msg, data, *args) current_span = OpenTelemetry::Trace.current_span trace_id = current_span.context.trace_id hex_trace_id = trace_id.unpack1(&#39;H*&#39;) span_id = current_span.context.span_id hex_span_id = span_id.unpack1(&#39;H*&#39;) attributes = [] args.each_with_index do |arg, index| # The next argument can be anything. attributes.push(arg) end # prepare log and return it log = { level: severity, time: time, msg: msg, trace_id: hex_trace_id, span_id: hex_span_id, trace_flags: &#39;00&#39;, node_id: RAILS_NODE_ID, progname: progname || PROGRAM_NAME, } # Get request id from Thread context. # It must not be empty since we should always set it in the first middleware. if !Thread.current[:request_id].nil? &amp;&amp; !Thread.current[:request_id].empty? log[:request_id] = Thread.current[:request_id] end # Check if a variable is a Hash using instance_of? # If data is not a Hash, it will become attributes. if !data.nil? &amp;&amp; !data.empty? if data.instance_of?(Hash) log[:data] = data else attributes.push(data) end end if !attributes.nil? &amp;&amp; !attributes.empty? log[:attributes] = attributes end return log.to_json end # debug_ctx will format the arguments as JSON and the print it using STDOUT.puts # This uses block (debug{}) instead of function call (debug()) to make it memory efficient. # https://stackoverflow.com/a/30144402 # Since the original Ruby ::Logger has debug, info, warn, error, fatal and unknown logger, # we add suffixes _ctx which take multiple arguments and the first argument must String which is the message log. # We get the program name using self as it access the parent class: # https://github.com/ruby/logger/blob/4e8d9e27fd3b8f916cd3b370b97359f67e02c4bb/lib/logger.rb#L420-L421 def debug_ctx(msg, data, *args) self.debug do log = format_json(&#34;DEBUG&#34;, Time.now, self.progname, msg, data, *args) STDOUT.puts(log) return &#34;&#34; end end def info_ctx(msg, data, *args) self.info do log = format_json(&#34;INFO&#34;, Time.now, self.progname, msg, data, *args) STDOUT.puts(log) return &#34;&#34; end end def warn_ctx(msg, data) self.warn do log = format_json(&#34;WARN&#34;, Time.now, self.progname, msg, data, *args) STDOUT.puts(log) return &#34;&#34; end end def error_ctx(msg, data) self.error do log = format_json(&#34;ERROR&#34;, Time.now, self.progname, msg, data, *args) STDOUT.puts(log) return &#34;&#34; end end def fatal_ctx(msg, data) self.fatal do log = format_json(&#34;FATAL&#34;, Time.now, self.progname, msg, data, *args) STDOUT.puts(log) return &#34;&#34; end end def unknown_ctx(msg, data, *args) self.debug do log = format_json(&#34;UNKNOWN&#34;, Time.now, self.progname, msg, data) STDOUT.puts(log) return &#34;&#34; end end end # end of class Json MyLogger = ActiveSupport::Logger.new(STDOUT) Then import that file from config/boot.rb, add:
require_relative &#34;logger_active_record_json&#34; Restart the server and now access our endpoint http://localhost:3000/list-vouchers?token={your-token}. Now, our log must show all log in JSON format output:
Figure 7. Rails Logger After Duck-Typing ActiveRecord::Logger Rails Logger After Duck-Typing ActiveRecord::Logger myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.328+00:00&#34;,&#34;msg&#34;:&#34;Booting Puma&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.328+00:00&#34;,&#34;msg&#34;:&#34;Rails 7.0.4.2 application starting in development &#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.328+00:00&#34;,&#34;msg&#34;:&#34;Run \`bin/rails server --help\` for more startup options&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.440+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Trilogy failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.441+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActiveSupport was successfully installed with the following options {}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.442+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Rack was successfully installed with the following options {:allowed_request_headers=\\u003e[], :allowed_response_headers=\\u003e[], :application=\\u003enil, :record_frontend_span=\\u003efalse, :retain_middleware_names=\\u003efalse, :untraced_endpoints=\\u003e[], :url_quantization=\\u003enil, :untraced_requests=\\u003enil, :response_propagators=\\u003e[]}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.445+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActionPack was successfully installed with the following options {}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.455+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActiveJob was successfully installed with the following options {:propagation_style=\\u003e:link, :force_flush=\\u003efalse, :span_naming=\\u003e:queue}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.558+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActiveRecord was successfully installed with the following options {}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActionView was successfully installed with the following options {:disallowed_notification_payload_keys=\\u003e[], :notification_payload_transform=\\u003enil}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::AwsSdk failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Bunny failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::LMDB failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::HTTP failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Koala failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.559+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ActiveModelSerializers failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::ConcurrentRuby was successfully installed with the following options {}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Dalli failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::DelayedJob failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Ethon failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Excon failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Faraday failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::GraphQL failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::HttpClient failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Mongo failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.560+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Mysql2 failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.561+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Net::HTTP was successfully installed with the following options {:untraced_hosts=\\u003e[]}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::PG was successfully installed with the following options {:peer_service=\\u003enil, :db_statement=\\u003e:include}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Que failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Racecar failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Rails was successfully installed with the following options {}&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Rake failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.562+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Rdkafka failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Redis failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::RestClient failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Resque failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::RubyKafka failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Sidekiq failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;WARN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.563+00:00&#34;,&#34;msg&#34;:&#34;Instrumentation: OpenTelemetry::Instrumentation::Sinatra failed to install&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Puma starting in single mode...&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Puma version: 5.6.5 (ruby 3.2.1-p31) (\\&#34;Birdie&#39;s Version\\&#34;)&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Min threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Max threads: 5&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Environment: development&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;PID: 1&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Listening on http://0.0.0.0:3000&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;UNKNOWN&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:40.694+00:00&#34;,&#34;msg&#34;:&#34;Use Ctrl-C to stop&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.537+00:00&#34;,&#34;msg&#34;:&#34;Started GET \\&#34;/list-vouchers?token=[FILTERED]\\&#34; for 172.19.0.1 at 2023-04-03 09:39:51 +0000&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.537+00:00&#34;,&#34;msg&#34;:&#34;Started GET \\&#34;/list-vouchers?token=[FILTERED]\\&#34; for 172.19.0.1 at 2023-04-03 09:39:51 +0000&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.538+00:00&#34;,&#34;msg&#34;:&#34;Cannot render console from 172.19.0.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.539+00:00&#34;,&#34;msg&#34;:&#34;Cannot render console from 172.19.0.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.661+00:00&#34;,&#34;msg&#34;:&#34; \\u001b[1m\\u001b[36mActiveRecord::SchemaMigration Pluck (3.4ms)\\u001b[0m \\u001b[1m\\u001b[34mSELECT \\&#34;schema_migrations\\&#34;.\\&#34;version\\&#34; FROM \\&#34;schema_migrations\\&#34; ORDER BY \\&#34;schema_migrations\\&#34;.\\&#34;version\\&#34; ASC\\u001b[0m&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.661+00:00&#34;,&#34;msg&#34;:&#34; \\u001b[1m\\u001b[36mActiveRecord::SchemaMigration Pluck (3.4ms)\\u001b[0m \\u001b[1m\\u001b[34mSELECT \\&#34;schema_migrations\\&#34;.\\&#34;version\\&#34; FROM \\&#34;schema_migrations\\&#34; ORDER BY \\&#34;schema_migrations\\&#34;.\\&#34;version\\&#34; ASC\\u001b[0m&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.690+00:00&#34;,&#34;msg&#34;:&#34;Processing by UserPromotionController#list_vouchers as HTML&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.690+00:00&#34;,&#34;msg&#34;:&#34;Processing by UserPromotionController#list_vouchers as HTML&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.690+00:00&#34;,&#34;msg&#34;:&#34; Parameters: {\\&#34;token\\&#34;=\\u003e\\&#34;[FILTERED]\\&#34;}&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.690+00:00&#34;,&#34;msg&#34;:&#34; Parameters: {\\&#34;token\\&#34;=\\u003e\\&#34;[FILTERED]\\&#34;}&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.694+00:00&#34;,&#34;msg&#34;:&#34;request accepted by controller&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.694+00:00&#34;,&#34;msg&#34;:&#34;request accepted by controller&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.694+00:00&#34;,&#34;msg&#34;:&#34;accepting token from query params&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.695+00:00&#34;,&#34;msg&#34;:&#34;accepting token from query params&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.695+00:00&#34;,&#34;msg&#34;:&#34;validating JWT&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.695+00:00&#34;,&#34;msg&#34;:&#34;validating JWT&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.697+00:00&#34;,&#34;msg&#34;:&#34;reaching business logic&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.697+00:00&#34;,&#34;msg&#34;:&#34;reaching business logic&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.697+00:00&#34;,&#34;msg&#34;:&#34;doing query get user by id c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.697+00:00&#34;,&#34;msg&#34;:&#34;doing query get user by id c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.706+00:00&#34;,&#34;msg&#34;:&#34; \\u001b[1m\\u001b[36mUser Load (1.5ms)\\u001b[0m \\u001b[1m\\u001b[34mSELECT \\&#34;users\\&#34;.* FROM \\&#34;users\\&#34; WHERE \\&#34;users\\&#34;.\\&#34;id\\&#34; = $1 LIMIT $2\\u001b[0m [[\\&#34;id\\&#34;, \\&#34;c8c6991c-687e-44cc-8755-4743ef66d265\\&#34;], [\\&#34;LIMIT\\&#34;, 1]]&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;64b1c2051f3fdefa&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.706+00:00&#34;,&#34;msg&#34;:&#34; \\u001b[1m\\u001b[36mUser Load (1.5ms)\\u001b[0m \\u001b[1m\\u001b[34mSELECT \\&#34;users\\&#34;.* FROM \\&#34;users\\&#34; WHERE \\&#34;users\\&#34;.\\&#34;id\\&#34; = $1 LIMIT $2\\u001b[0m [[\\&#34;id\\&#34;, \\&#34;c8c6991c-687e-44cc-8755-4743ef66d265\\&#34;], [\\&#34;LIMIT\\&#34;, 1]]&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;64b1c2051f3fdefa&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.707+00:00&#34;,&#34;msg&#34;:&#34; â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39;&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;64b1c2051f3fdefa&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.707+00:00&#34;,&#34;msg&#34;:&#34; â†³ app/services/vouchers/user_voucher.rb:7:in \`vouchers&#39;&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;64b1c2051f3fdefa&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.713+00:00&#34;,&#34;msg&#34;:&#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.713+00:00&#34;,&#34;msg&#34;:&#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.715+00:00&#34;,&#34;msg&#34;:&#34;PromotionService.list_vouchers call started&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:51.715+00:00&#34;,&#34;msg&#34;:&#34;PromotionService.list_vouchers call started&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.127+00:00&#34;,&#34;msg&#34;:&#34;PromotionService.list_vouchers done&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.128+00:00&#34;,&#34;msg&#34;:&#34;PromotionService.list_vouchers done&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.129+00:00&#34;,&#34;msg&#34;:&#34;controller done processing the request, preparing rendering response&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.129+00:00&#34;,&#34;msg&#34;:&#34;controller done processing the request, preparing rendering response&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.140+00:00&#34;,&#34;msg&#34;:&#34;Completed 200 OK in 450ms (Views: 5.5ms | ActiveRecord: 5.8ms | Allocations: 11549)\\n\\n&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} myapp | {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T09:39:52.141+00:00&#34;,&#34;msg&#34;:&#34;Completed 200 OK in 450ms (Views: 5.5ms | ActiveRecord: 5.8ms | Allocations: 11549)\\n\\n&#34;,&#34;trace_id&#34;:&#34;4862c816e54cf50f3d0147068a88ccc7&#34;,&#34;span_id&#34;:&#34;872682563d412c74&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;ac8d3e07-387e-4287-ac2f-4f9414c5504f&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} Now, as we already add the Jaeger service in the section Add OpenTelemetry SDK, we can see our trace in Jaeger dashboard by accessing JaegerUI http://localhost:16686/search.
And we will see one trace like this (because we only do request once only):
Figure 8. JaegerUI To See App Trace In our log we see that we have a trace id 4862c816e54cf50f3d0147068a88ccc7 and, it match with the Trace ID shown in JaegerUI in http://localhost:16686/trace/4862c816e54cf50f3d0147068a88ccc7.
So, we have two questions:
How to make this trace id available from the client side? To do this, we want to add key Traceparent available in HTTP response header by creating OpenTelemetry Middleware. This comply with the W3 Recommendation. What is additional function with suffixes _ctx such as debug_ctx, info_ctx, etc do? And how to use that? I will cover it in the section Changes on this section can be seen at this commit e7ad9f7.
Creating OpenTelemetry Middleware # We need to create a OpenTelemetry middleware in the first middleware stack to ensure:
If the endpoint is called from another service that already start the tracer, we only need to continue from that tracer ID as the parent. If we don&rsquo;t do this, it will create new trace that not correlate with the previous trace &ndash; and this is bad, because we can&rsquo;t observe and correlate the API calls. We add Traceparent in response header. This way, the caller (or client who call the app) can see the Trace ID produced by the app. We print access log in this middleware to ensure we can get request-response log. To do that, create a file config/middleware_otel.rb:
require &#39;securerandom&#39; require &#34;opentelemetry/sdk&#34; require &#39;rack/request&#39; require_relative &#34;logger_active_record_json&#34; # # Export traces to console by default # # see https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/sdk/lib/opentelemetry/sdk/configurator.rb#L175-L197 # ENV[&#39;OTEL_TRACES_EXPORTER&#39;] ||= &#39;otlp&#39; # # Configure propagator # # see https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/sdk/lib/opentelemetry/sdk/configurator.rb#L199-L216 # ENV[&#39;OTEL_PROPAGATORS&#39;] ||= &#39;tracecontext,baggage,b3&#39; # MiddlewareLogger this code is based on below link with modification. # https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/examples/http/server.rb module MiddlewareLogger class RequestContextMiddleware def initialize(app) @app = app end def call(env) start_time = Time.now # Extract context from request headers. # This to continue the span if client has sent some propagator key into request header. context = OpenTelemetry.propagation.extract( env, # see https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/common/lib/opentelemetry/common/propagation.rb#L22 # and https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/common/lib/opentelemetry/common/propagation/rack_env_getter.rb getter: OpenTelemetry::Common::Propagation.rack_env_getter, ) # Example: get OpenTelemetry trace id. # Trace ID will always the same as traceparent (if exist and continue from client), # or from new current span. # trace_id = OpenTelemetry::Trace.current_span.context.trace_id.unpack1(&#39;H*&#39;) # Unpack to hex # We use MyAppTracer that we defined in config/initializers/opentelemetry.rb # For attribute naming, see # https://github.com/open-telemetry/opentelemetry-specification/blob/v1.19.0/specification/trace/semantic_conventions/http.md#http-server attributes = { &#39;component&#39; =&gt; &#39;http&#39;, &#39;http.method&#39; =&gt; env[&#39;REQUEST_METHOD&#39;], &#39;http.route&#39; =&gt; env[&#39;PATH_INFO&#39;], &#39;http.url&#39; =&gt; env[&#39;REQUEST_URI&#39;], } # Span name SHOULD be set to route: span_name = &#34;#{env[&#39;REQUEST_METHOD&#39;]} #{env[&#39;PATH_INFO&#39;]}&#34; span = MyAppTracer.start_span(span_name, with_parent: context, attributes: attributes) # Extract relevant information from the request object # see full object here https://rubydoc.info/gems/rack/Rack/Request request = Rack::Request.new(env) req_method = request.request_method || &#39;&#39; req_path = request.path || &#39;&#39; req_url = env[&#39;REQUEST_URI&#39;] || &#39;&#39; req_user_agent = request.user_agent || &#39;&#39; req_remote_ip = request.ip || &#39;&#39; # Get X-Request-ID value header. This is non W3 standard headers: https://stackoverflow.com/a/27174552 # But, Heroku has blog about this https://blog.heroku.com/http_request_id_s_improve_visibility_across_the_application_stack request_id = SecureRandom.uuid() # Get header request values req_headers = {} req_headers_filter = env.select { |key, value| key.start_with?(&#39;HTTP_&#39;) } req_headers_filter.each do |key, value| if key.downcase == &#39;X-Request-ID&#39;.downcase request_id = value.chomp() end req_headers[key] = value end # Pass the information to the logger log_data = { request: { method: req_method, path: req_path, url: req_url, user_agent: req_user_agent, remote_ip: req_remote_ip, # uncomment if you need all request header passed in every log. # But, this will return a big object that makes your log hard to see. # header: req_headers, }, } # Prepare default response resp_status, resp_headers, resp_body = 200, {}, &#39;&#39; # Activate the extracted context # set the span as the current span in the OpenTelemetry context OpenTelemetry::Trace.with_span(span) do # Call the next middleware in the chain # Run application stack span.set_attribute(&#39;request_id&#39;, request_id) resp_status, resp_headers, resp_body = @app.call(env) span.set_attribute(&#39;http.status_code&#39;, resp_status) end # Inject &#34;traceparent&#34; to header response # see https://github.com/open-telemetry/opentelemetry-ruby/blob/opentelemetry-sdk/v1.2.0/sdk/lib/opentelemetry/sdk/configurator.rb#L17 OpenTelemetry.propagation.inject(resp_headers) # Inject &#34;X-Request-Id&#34; to header response. # The request id must the same as request id if any, if not we already generated one during getting request headers. resp_headers[&#39;X-Request-Id&#39;] = request_id log_data[:response] = { status: resp_status, header: resp_headers, } # return the response after it processed on the next call return resp_status, resp_headers, resp_body rescue Exception =&gt; e # set the span status to error if an exception is raised span.record_exception(e) # re-raise the exception raise e ensure MyLogger.info_ctx(&#39;access log&#39;, log_data) # Clear the request context data from the thread-local variable Thread.current[:request_id] = nil # end the span when the request is complete span.finish end end end And in the file config/application.rb we need to:
require_relative &#34;middleware_otel&#34; and add this config:
# push the MiddlewareLogger::RequestContextMiddleware to head of middleware stack config.middleware.insert_before(0, MiddlewareLogger::RequestContextMiddleware) Again, restart the application and make some requests. To validate that we already put the Traceparent in the response header, we can use curl:
curl -v http://localhost:3000/list-vouchers?token={your-token} Figure 9. cURL To Validate Traceparent Header cURL To Validate Traceparent Header curl -v http://localhost:3000/list-vouchers\\?token\\=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 * Trying 127.0.0.1:3000... * Connected to localhost (127.0.0.1) port 3000 (#0) &gt; GET /list-vouchers?token=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 HTTP/1.1 &gt; Host: localhost:3000 &gt; User-Agent: curl/7.86.0 &gt; Accept: */* &gt; * Mark bundle as not supporting multiuse &lt; HTTP/1.1 200 OK &lt; X-Frame-Options: SAMEORIGIN &lt; X-XSS-Protection: 0 &lt; X-Content-Type-Options: nosniff &lt; X-Download-Options: noopen &lt; X-Permitted-Cross-Domain-Policies: none &lt; Referrer-Policy: strict-origin-when-cross-origin &lt; Content-Type: */*; charset=utf-8 &lt; Vary: Accept &lt; ETag: W/&#34;0a89d7478ece4a7e8d2b8acbc102aff6&#34; &lt; Cache-Control: max-age=0, private, must-revalidate &lt; X-Request-Id: b243ea12-3394-4c49-8faa-ae6f266ff1b7 &lt; X-Runtime: 0.460178 &lt; Server-Timing: start_processing.action_controller;dur=0.32, sql.active_record;dur=1.08, instantiation.active_record;dur=0.04, process_action.action_controller;dur=437.60 &lt; traceparent: 00-a1ac0334fcb72ad1513859d416b5ff26-b819e2324b94eacd-01 &lt; Transfer-Encoding: chunked &lt; * Connection #0 to host localhost left intact {&#34;user&#34;:{&#34;id&#34;:&#34;c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;username&#34;:&#34;jane&#34;,&#34;name&#34;:&#34;Jane Kepiye Karepe To&#34;,&#34;created_at&#34;:&#34;2023-03-02T09:15:51.346Z&#34;,&#34;updated_at&#34;:&#34;2023-03-02T09:15:51.346Z&#34;},&#34;vouchers&#34;:[[{&#34;voucher_code&#34;:&#34;REGISTER_ANNIVERSARY&#34;,&#34;description&#34;:&#34;will get 5% discount if user is a loyal users (already joined minimum 1 year)&#34;,&#34;terms_and_conditions&#34;:[{&#34;discount&#34;:5,&#34;min_registered_year&#34;:1,&#34;registered_date_is_same&#34;:true,&#34;registered_month_is_same&#34;:true,&#34;name_prefix&#34;:&#34;&#34;}]}],[{&#34;voucher_code&#34;:&#34;I_AM_JAN&#34;,&#34;description&#34;:&#34;will get 1% discount if user have name prefix &#39;jan&#39; because our app is launched at January!&#34;,&#34;terms_and_conditions&#34;:[{&#34;discount&#34;:1,&#34;min_registered_year&#34;:0,&#34;registered_date_is_same&#34;:false,&#34;registered_month_is_same&#34;:false,&#34;name_prefix&#34;:&#34;&#34;}]}]]} Also, in the application log, we will see access log with JSON format (Figure 10). We produce request-response data inside field data in the log.
Figure 10. Application Log After Adding OpenTelemetry Middleware { &#34;level&#34;: &#34;INFO&#34;, &#34;time&#34;: &#34;2023-04-03T10:14:17.202+00:00&#34;, &#34;msg&#34;: &#34;access log&#34;, &#34;trace_id&#34;: &#34;a1ac0334fcb72ad1513859d416b5ff26&#34;, &#34;span_id&#34;: &#34;b819e2324b94eacd&#34;, &#34;trace_flags&#34;: &#34;00&#34;, &#34;node_id&#34;: &#34;249e7240-36af-49b9-8f82-6cfb2870de34&#34;, &#34;progname&#34;: &#34;rails-otel&#34;, &#34;data&#34;: { &#34;request&#34;: { &#34;method&#34;: &#34;GET&#34;, &#34;path&#34;: &#34;/list-vouchers&#34;, &#34;url&#34;: &#34;/list-vouchers?token=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14&#34;, &#34;user_agent&#34;: &#34;curl/7.86.0&#34;, &#34;remote_ip&#34;: &#34;172.19.0.1&#34; }, &#34;response&#34;: { &#34;status&#34;: 200, &#34;header&#34;: { &#34;X-Frame-Options&#34;: &#34;SAMEORIGIN&#34;, &#34;X-XSS-Protection&#34;: &#34;0&#34;, &#34;X-Content-Type-Options&#34;: &#34;nosniff&#34;, &#34;X-Download-Options&#34;: &#34;noopen&#34;, &#34;X-Permitted-Cross-Domain-Policies&#34;: &#34;none&#34;, &#34;Referrer-Policy&#34;: &#34;strict-origin-when-cross-origin&#34;, &#34;Content-Type&#34;: &#34;*/*; charset=utf-8&#34;, &#34;Vary&#34;: &#34;Accept&#34;, &#34;ETag&#34;: &#34;W/\\&#34;0a89d7478ece4a7e8d2b8acbc102aff6\\&#34;&#34;, &#34;Cache-Control&#34;: &#34;max-age=0, private, must-revalidate&#34;, &#34;X-Request-Id&#34;: &#34;b243ea12-3394-4c49-8faa-ae6f266ff1b7&#34;, &#34;X-Runtime&#34;: &#34;0.460178&#34;, &#34;Server-Timing&#34;: &#34;start_processing.action_controller;dur=0.32, sql.active_record;dur=1.08, instantiation.active_record;dur=0.04, process_action.action_controller;dur=437.60&#34;, &#34;traceparent&#34;: &#34;00-a1ac0334fcb72ad1513859d416b5ff26-b819e2324b94eacd-01&#34; }, &#34;latency&#34;: 467.365584 } } } Changes on this section can be seen at this commit 5467b1b.
Using Custom Logger Function # If you follow this tutorial carefully, you may notice that we now have new logger class called MyLogger that replace (duck-typing) the ActiveRecord::Logger. In the previous section we use MyLogger.info_ctx which takes 2 arguments. In Rails.logger.info it only accepts one argument, and will return error when we pass more arguments.
MyLogger.info_ctx(&#34;message&#34;, {key: &#34;value on data&#34;}, {attribute: 1}, {attribute: &#34;two&#34;}) # {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T10:22:49.453+00:00&#34;,&#34;msg&#34;:&#34;message&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;6f8d4021-f917-4ee7-84f4-2aa903ba6e63&#34;,&#34;progname&#34;:&#34;rails-otel&#34;,&#34;data&#34;:{&#34;key&#34;:&#34;value on data&#34;},&#34;attributes&#34;:[{&#34;attribute&#34;:1},{&#34;attribute&#34;:&#34;two&#34;}]} Rails.logger.info(&#34;message&#34;, {key: &#34;value on data&#34;}, {attribute: 1}, {attribute: &#34;two&#34;}) # /usr/local/lib/ruby/3.2.0/logger.rb:694:in \`info&#39;: wrong number of arguments (given 4, expected 0..1) (ArgumentError) Rails.logger.info(&#34;message&#34;) # {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T10:23:14.739+00:00&#34;,&#34;msg&#34;:&#34;message&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;6f8d4021-f917-4ee7-84f4-2aa903ba6e63&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} # {&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2023-04-03T10:23:14.739+00:00&#34;,&#34;msg&#34;:&#34;message&#34;,&#34;trace_id&#34;:&#34;00000000000000000000000000000000&#34;,&#34;span_id&#34;:&#34;0000000000000000&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;6f8d4021-f917-4ee7-84f4-2aa903ba6e63&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} All new function that we write in section Duck-typing the Ruby ActiveRecord Logger is to make our life easier to produce the log with data. For example, in access log we need a data with structure:
{ &#34;data&#34;: { &#34;request&#34;: {}, &#34;response&#34;: {} } } But in another case such as publishing message to Kafka we only want to produce data with:
{ &#34;data&#34;: { &#34;kafka_topic&#34;: &#34;&#34;, &#34;payload&#34;: {} } } Also, we accept the 3rd arguments as an optional parameter. It can accepts any value as long as it can be decoded into JSON (i.e: Hash as JSON object, Array as JSON array, etc). It useful when we want to add some information that only available in certain function. For example, we cannot get the username from the access log because the OpenTelemetry middleware should be installed in the first stack (in the sample code we place it in the business logic level code), so it cannot be printed in the middleware. username value is only available after this line.
So, we can change our code a bit.
From:
Rails.logger.debug &#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers #{user_id}&#34; That produces log:
{&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T10:43:45.525+00:00&#34;,&#34;msg&#34;:&#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;trace_id&#34;:&#34;26136c1a589d1a1735e517f36a4c71ed&#34;,&#34;span_id&#34;:&#34;f32d0b8848232ea8&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;1312c7ba-d448-42a5-95d5-0bb32b837d61&#34;,&#34;progname&#34;:&#34;rails-otel&#34;} To:
Rails.logger.debug_ctx( &#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers&#34;, nil, {username: user.username}, ) That produces:
{&#34;level&#34;:&#34;DEBUG&#34;,&#34;time&#34;:&#34;2023-04-03T10:44:38.701+00:00&#34;,&#34;msg&#34;:&#34;calling PromotionService.list_vouchers from UserVoucher.list_vouchers&#34;,&#34;trace_id&#34;:&#34;6c93b69dd5e395f20c5338375a540bd5&#34;,&#34;span_id&#34;:&#34;72a37953b7e9cd79&#34;,&#34;trace_flags&#34;:&#34;00&#34;,&#34;node_id&#34;:&#34;1312c7ba-d448-42a5-95d5-0bb32b837d61&#34;,&#34;progname&#34;:&#34;rails-otel&#34;,&#34;attributes&#34;:[{&#34;username&#34;:&#34;jane&#34;}]} Changes on this section can be seen at this commit 81ffd38.
Bonus: Add Trace using OpenTelemetry # When you see on Figure 8, you see that in one request there will be 25 spans. But, after adding OpenTelemetry middleware, it will be 26 spans because we adding new span here.
span_name = &#34;#{env[&#39;REQUEST_METHOD&#39;]} #{env[&#39;PATH_INFO&#39;]}&#34; span = MyAppTracer.start_span(span_name, with_parent: context, attributes: attributes) But, the interesting thing is when we look at the Figure 11, the first request with trace ID 691f94e (Figure 12) has more Span than second request (trace ID fbcc7d5, Figure 13). Also, we notice that in the third request it has 20 spans but before that, the Rails produce the DEALLOCATE span (Figure 14).
Figure 11. Jaeger UI With More Traces Here&rsquo;s the timeline of the requests, and it&rsquo;s Trace ID:
April 4 2023, 09:26:13.485 -&gt; 691f94e426b88f0c96a1c38b7ecbceb9 -&gt; Figure 12 April 4 2023, 09:26:15.277 -&gt; fbcc7d5139bcaf6cbe9755a8b95f4503 -&gt; Figure 13 April 4 2023, 09:31:57.623 -&gt; 43bb5b582cb4c8e801dce2449e61aca6 -&gt; Figure 14 April 4 2023, 09:33:07.753 -&gt; e8453e2284e26bf1a4bbf4b5ddeb7c8e -&gt; Figure 15 April 4 2023, 09:33:08.984 -&gt; 2d0666880d55e6e194cc6a89d02634f4 -&gt; Figure 16 April 4 2023, 09:33:10.040 -&gt; d2fcb8edaa56c09fd1cf4efcddebe3b9 -&gt; Figure 17 Collection of JaegerUI Figure 12. Jaeger UI Trace ID 691f94e426b88f0c96a1c38b7ecbceb9 Figure 13. Jaeger UI Trace ID fbcc7d5139bcaf6cbe9755a8b95f4503 Figure 14. Jaeger UI Trace ID 43bb5b582cb4c8e801dce2449e61aca6 Figure 15. Jaeger UI Trace ID e8453e2284e26bf1a4bbf4b5ddeb7c8e Figure 16. Jaeger UI Trace ID 2d0666880d55e6e194cc6a89d02634f4 Figure 17. Jaeger UI Trace ID d2fcb8edaa56c09fd1cf4efcddebe3b9 But, I don&rsquo;t want to focus on this, I assume that those behavior is part of the magic from Rails framework.
In this section, I want to show you how to add new span. For example, in the trace ID d2fcb8edaa56c09fd1cf4efcddebe3b9 (Figure 17), we only have 5 spans. Which create the waterfall like this:
UserPromotionController#list_vouchers -&gt; GET /list-vouchers -&gt; rails_otel_dev -&gt; User.find_by_sql -&gt; EXECUTE rails_otel_dev But, in our code we have some function that does not show in the span such as function Vouchers::UserVoucher::vouchers which then call Promotions::PromotionService::list_vouchers. To make it visible, we need to wrap our code with this block:
MyAppTracer.in_span(&#34;your span name&#34;) do |span| # the rest of your code that want be traced end This is documented here on the release tag 2023.04.
Now, if we access our app, the JaegerUI tracing will show as shown in Figure 18.
curl -v http://localhost:3000/list-vouchers\\?token\\=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 * Trying 127.0.0.1:3000... * Connected to localhost (127.0.0.1) port 3000 (#0) &gt; GET /list-vouchers?token=eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYzhjNjk5MWMtNjg3ZS00NGNjLTg3NTUtNDc0M2VmNjZkMjY1In0.TCrEUFziQY4800jAT9ioY2mOm_b9eLdC20gtXjdTt14 HTTP/1.1 &gt; Host: localhost:3000 &gt; User-Agent: curl/7.86.0 &gt; Accept: */* &gt; * Mark bundle as not supporting multiuse &lt; HTTP/1.1 200 OK &lt; X-Frame-Options: SAMEORIGIN &lt; X-XSS-Protection: 0 &lt; X-Content-Type-Options: nosniff &lt; X-Download-Options: noopen &lt; X-Permitted-Cross-Domain-Policies: none &lt; Referrer-Policy: strict-origin-when-cross-origin &lt; Content-Type: */*; charset=utf-8 &lt; Vary: Accept &lt; ETag: W/&#34;0a89d7478ece4a7e8d2b8acbc102aff6&#34; &lt; Cache-Control: max-age=0, private, must-revalidate &lt; X-Request-Id: d8c74eb4-4b80-4824-a40d-f82881b3bba2 &lt; X-Runtime: 0.411438 &lt; Server-Timing: start_processing.action_controller;dur=0.64, sql.active_record;dur=3.71, instantiation.active_record;dur=0.44, process_action.action_controller;dur=377.52 &lt; traceparent: 00-a8f1b4a938dd800bef349037d25b9524-f63a980145e5e597-01 &lt; Transfer-Encoding: chunked &lt; * Connection #0 to host localhost left intact {&#34;user&#34;:{&#34;id&#34;:&#34;c8c6991c-687e-44cc-8755-4743ef66d265&#34;,&#34;username&#34;:&#34;jane&#34;,&#34;name&#34;:&#34;Jane Kepiye Karepe To&#34;,&#34;created_at&#34;:&#34;2023-03-02T09:15:51.346Z&#34;,&#34;updated_at&#34;:&#34;2023-03-02T09:15:51.346Z&#34;},&#34;vouchers&#34;:[[{&#34;voucher_code&#34;:&#34;REGISTER_ANNIVERSARY&#34;,&#34;description&#34;:&#34;will get 5% discount if user is a loyal users (already joined minimum 1 year)&#34;,&#34;terms_and_conditions&#34;:[{&#34;discount&#34;:5,&#34;min_registered_year&#34;:1,&#34;registered_date_is_same&#34;:true,&#34;registered_month_is_same&#34;:true,&#34;name_prefix&#34;:&#34;&#34;}]}],[{&#34;voucher_code&#34;:&#34;I_AM_JAN&#34;,&#34;description&#34;:&#34;will get 1% discount if user have name prefix &#39;jan&#39; because our app is launched at January!&#34;,&#34;terms_and_conditions&#34;:[{&#34;discount&#34;:1,&#34;min_registered_year&#34;:0,&#34;registered_date_is_same&#34;:false,&#34;registered_month_is_same&#34;:false,&#34;name_prefix&#34;:&#34;&#34;}]}]]}% Figure 18. Jaeger UI Trace ID a8f1b4a938dd800bef349037d25b9524 After Adding More Span Changes on this section can be seen at this commit 89bd3f9.
Conclusion # After installing OpenTelemetry and duck-typing some classes, now we have all our log formatted to JSON. Now we can pipe this log into Elasticsearch or any logging tools that support query. By using that, we can easily to group the log based on trace_id.
`})})()